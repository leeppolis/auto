<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Auto</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Coda:wght@400;800&display=swap" rel="stylesheet">
    <style>
      body {
        background: #EDEAE3;
        border: 0;
        color: #2F4858;
        font-family: Montserrat, 'Coda', cursive;
        font-weight: 400;
        margin: 0;
        padding: 0;
      }

      .wrapper {
        display: block;
        margin: 0 auto;
        width: 1320px;
      }

      h2,
      h1 {
        font-size: 42px;
        font-weight: 800;
        margin: 40px 0 0 0;
        text-align: center;
        text-transform: uppercase;
      }

      h2 {
        font-size: 18px;
        margin: 0 0 40px 0;
      }

      svg text {
        fill: #2F4858;
      }

      .header {
        alignment-baseline: middle;
        font-size: 14px;
        font-weight: 300;
      }

      .column-header {
        font-weight: 500;
        text-anchor: middle;
      }

      .row-header {
        font-size: 12px;
        font-weight: 500;
        text-anchor: end;
      }

      .row-header.selected {
        font-weight: 700;
      }

      .summary {
        font-size: 12px;
        alignment-baseline: middle;
      }

      .summary.selected {
        font-weight: 700;
      }

      .summary-year {
        text-anchor: middle;
      }

      .bar-label {
        alignment-baseline: bottom;
        font-size: 12px;
        font-weight: 600;
        opacity: 0;
        text-anchor: middle;
        text-shadow: 1px 0 0 #EDEAE3,
          0 1px 0 #EDEAE3,
          -1px 0 0 #EDEAE3,
          0 -1px 0 #EDEAE3,
          1px 1px 0 #EDEAE3,
          -1px -1px 0 #EDEAE3,
          -1px 1px 0 #EDEAE3,
          1px -1px 0 #EDEAE3;

      }

      .bar-label.selected {
        opacity: 1;
      }

      .bar {
        opacity: 1;
        stroke-width: 1;
      }

      .bar.selected {
        opacity: 1;
      }

      .bar-cat-shadow {
        opacity: .15;
      }

      .line-line,
      .connector {
        fill: none;
        stroke-width: 1;
        stroke-dasharray: 4 4;
      }

      .line-dot {
        fill: #fff;
        stroke: #2F4858;
        stroke-width: 1;
      }

      .line-label {
        alignment-baseline: bottom;
        font-size: 12px;
        text-anchor: middle;
      }

      .line-guide {
        stroke: #2F4858;
        stroke-width: 1;
        stroke-dasharray: none;
      }

      #small-m {
        display: flex;
        flex-wrap: wrap;
      }

      .single {
        display: block;
        flex: 0 0 33.33%;
        height: 220px;
        margin-bottom: 20px;
        min-height: 100px;
        position: relative;
      }

      .single .container {
        bottom: 10px;
        left: 10px;
        position: absolute;
        right: 10px;
        top: 10px;
      }

      .single svg {
        left: 0;
        position: absolute;
        bottom: 0;
        z-index: 0;
      }

      .single h3 {
        font-size: 14px;
        font-weight: 400;
        left: 50%;
        margin: 0;
        position: absolute;
        top: 0;
        transform: translate3d(-50%, 0, 0);
        z-index: 1;
      }

      .single h4 {
        font-weight: 800;
        left: 50%;
        margin: 0;
        position: absolute;
        top: 30px;
        transform: translate3d(-50%, 0, 0);
        z-index: 1;
      }

      .axis-label {
        font-size: 12px;
      }

      .annotation {
        font-size: 18px;
        font-weight: 700;
        text-shadow: 1px 0 0 #EDEAE3,
          0 1px 0 #EDEAE3,
          -1px 0 0 #EDEAE3,
          0 -1px 0 #EDEAE3,
          1px 1px 0 #EDEAE3,
          -1px -1px 0 #EDEAE3,
          -1px 1px 0 #EDEAE3,
          1px -1px 0 #EDEAE3;
      }

      .numbers {
        font-size: 12px;
        font-weight: 500;
        text-shadow: 1px 0 0 #EDEAE3,
          0 1px 0 #EDEAE3,
          -1px 0 0 #EDEAE3,
          0 -1px 0 #EDEAE3,
          1px 1px 0 #EDEAE3,
          -1px -1px 0 #EDEAE3,
          -1px 1px 0 #EDEAE3,
          1px -1px 0 #EDEAE3;
      }
    </style>
  </head>
  <body>
    <div class="wrapper">
      <h1>La Scalata degli Euro 6</h1> 
      <h2>Automobili private intestate a residenti nel Comune di Milano, serie storica 2011 - 2019</h2>
      <div id="line"></div>
      <div id="parallel"></div>
      <br /><br /><br /><br /><br /><br />
      <div id="small-m"></div>
    </div>

    <script>
      // Constants
      const SELECTED = 'EURO6';
      const dictionary = {
        EURO6: 'Euro 6',
        EURO5: 'Euro 5',
        EURO4: 'Euro 4',
        EURO3: 'Euro 3',
        EURO2: 'Euro 2',
        EURO1: 'Euro 1',
        EURO0: 'Euro 0',
        ANI: 'Non Identificato',
        ANC: 'Non Classificato',
      };
      const colors = {
        EURO6: '#79B598',
        EURO5: '#6AAB9E',
        EURO4: '#5C9AA0',
        EURO3: '#4E7B95',
        EURO2: '#40557E',
        EURO1: '#323566',
        EURO0: '#2D254D',
        ANI: '#9D4E7A',
        ANC: '#99A89E',
        NEUTRAL: '#6F8884',
        DEFAULT: '#2F4858333',
        EMPTY: '#EDEAE3',
        HIGHLIGHT: '#EDEAE3',
        TEXT: '#2F4858',
      };
      const maxBarWidth = 100;
      const barHeight = 8;
      const selectedBarHeight = 16;
      const rowHeight = 45;
      const columnWidth = 120;
      const lineChartHeight = 80;

      // Functions
      const getWidth = (value, maxValue) => {
        return Math.round(maxBarWidth * value / maxValue) || 5;
      };

      const getExtremes = (width, row, column) => {
        const half = (width / 2);
        const y = getYPos(row, false) + Math.round(barHeight / 2);
        return [[Math.ceil(getXPos(column) - half), y], [Math.floor(getXPos(column) + half), y]];
      }

      const getYPos = (line, selected = false) => {
        const bar = selected ? selectedBarHeight : barHeight;
        return (rowHeight + (line * rowHeight) + Math.round((rowHeight - bar) / 2));
      };

      const getXPos = column => (columnWidth + (column * columnWidth) + Math.round(columnWidth / 2));

      const formatNumber = (n) => d3Locale.format(',.0f')(n);

      const formatPercentage = (n) => d3Locale.format('+,.2%')(n);

      const d3Locale = d3.formatLocale({
        decimal: ',',
        thousands: '.',
        grouping: [3],
        currency: ['', '€']
      });
      
      // Load Data
      d3.json('./data/data.json')
        .then((data) => {
          console.log(data);
          const years = Object.keys(data).sort((a,b) => a - b);
          const categories = data[years[0]].sort((a, b) => b.numero - a.numero).map(c => c.classe);
          const svgW = columnWidth * (years.length + 2);
          const svgH = rowHeight * (categories.length + 1);
          const connectors = {};

          categories.forEach((c) => { connectors[c] = [] });
          const total = {};
          years.forEach((y) => {
            total[y] = data[y].reduce((acc, d) => acc + d.numero, 0);
          });
          // Lollipop
          (() => {
            const svgL = d3.select('#line')
              .append('svg')
              .attr('width', svgW)
              .attr('height', lineChartHeight)
              .attr('viewbox', `0 0 ${svgW} 200`)
              .attr('preserveAspectRatio', 'xMidYMid meet');

            const gL = svgL.append('g');
            const gG = svgL.append('g');
            const gD = svgL.append('g');
            const gLB = svgL.append('g');

            let maxValue = Number.MIN_SAFE_INTEGER;
            let minValue = Number.MAX_SAFE_INTEGER;
            years.forEach((y, i) => {
              maxValue = total[y] > maxValue ? total[y] : maxValue;
              minValue = total[y] < minValue ? total[y] : minValue;
            });
            const yScale = d3.scaleLinear()
              .domain([ minValue, maxValue ])
              .range([lineChartHeight - 20, 20]);
            let path = [`M${getXPos(0)} ${yScale(total[years[0]])}`];
            years.forEach((y, i) => {
              const xp = getXPos(i);
              const yp = yScale(total[y]);
              path.push(`L${xp} ${yp}`);

              gD.append('circle')
                .attr('cx', xp)
                .attr('cy', yp)
                .attr('r', 5)
                .attr('stroke', colors.DEFAULT)
                .attr('fill', colors.EMPTY)
                .attr('class','line-dot');

              gLB.append('text')
                .attr('x', xp)
                .attr('y', yp)
                .attr('dy', -8)
                .attr('class','line-label')
                .text(formatNumber(total[y]));

              gG.append('line')
                .attr('x1', xp)
                .attr('x2', xp)
                .attr('y1', lineChartHeight)
                .attr('y2', yp)
                .attr('stroke', colors.DEFAULT)
                .attr('class', 'line-guide');
            });
            gL.append('path')
              .attr('d', path.join(','))
              .attr('stroke', colors.NEUTRAL)
              .attr('class', 'line-line');
          })();

          // Parallel Coordinates
          (() => {
            const maxValue = 277675;
            const svgP = d3.select('#parallel').append('svg')
              .attr('width', svgW)
              .attr('height', svgH)
              .attr('viewbox', `0 0 ${svgW} ${svgH}`)
              .attr('preserveAspectRatio', 'xMidYMid meet');

            // Connectors Container needs to stay below everything
            const gCC = svgP.append('g')
              .attr('class', 'connectors');
            
            // Row / Column Header
            const gRH = svgP.append('g')
              .attr('class', 'headers row-headers');
            categories.forEach((c, i) => {
              gRH.append('text')
                .attr('x', columnWidth)
                .attr('dx', -15)
                .attr('y', ((i + 1) * rowHeight) + (rowHeight / 2))
                .attr('class', `header row-header ${c === SELECTED ? 'selected' : ''}`)
                .attr('id', `row-header-${c}`)
                .attr('data-category', `cat-${c}`)
                .text(dictionary[c]);
              gRH.append('circle')
                .attr('cx', columnWidth - 5)
                .attr('cy', ((i + 1) * rowHeight) + (rowHeight / 2))
                .attr('r', 3)
                .attr('fill', colors[c]);
            });

            const gCH = svgP.append('g')
              .attr('class', 'headers columns-headers');
            years.forEach((c, i) => {
              gCH.append('text')
                .attr('x', getXPos(i))
                .attr('y', rowHeight / 2)
                .attr('class', 'header column-header')
                .attr('id', `column-header-${c}`)
                .attr('data-category', `year-${c}`)
                .text(c);
            });

            // Years
            years.forEach((y, i) => {
              const barSources = data[y].sort((a, b) => b.numero - a.numero);
              const xPos = getXPos(i);
              const gYB = svgP.append('g')
                .attr('class', `year year-${y}`);
              
              barSources.forEach((b,l) => {
                const width = (b.numero > 0) ? getWidth(b.numero, maxValue) : 2;
                gYB.append('rect')
                  .attr('x', xPos)
                  .attr('y', getYPos(l, b.classe === SELECTED))
                  .attr('width', width)
                  .attr('height', b.classe === SELECTED ? selectedBarHeight : barHeight)
                  .attr('data-category', `cat-${b.classe} cat-${y}`)
                  .attr('transform',`translate(-${Math.round(width / 2)})`)
                  .attr('stroke', colors[b.classe])
                  .attr('fill', b.classe === SELECTED ? colors[b.classe] : `url('#fill')`)
                  .attr('class', `bar bar-year-${y} bar-cat-${b.classe} ${(b.numero > 0) ? '' : 'bar-cat-shadow'} ${b.classe === SELECTED ? 'selected' : ''}`);
                gYB.append('text')
                  .attr('x', xPos)
                  .attr('y', getYPos(l, b.classe === SELECTED))
                  .attr('dy', b.classe === SELECTED ? 12 : -2)
                  .attr('data-category', `cat-${b.classe} cat-${y}`)
                  .attr('class', `bar-label ${b.classe === SELECTED ? 'selected' : ''}`)
                  .text(formatNumber(b.numero));
                connectors[b.classe].push(getExtremes(width, l, i));
              });
            });

            // Connectors
            categories.forEach((c) => {
              const gCCS = gCC.append('g')
                .attr('class', `connector connector-${c}`)
                .attr('data-category', `cat-${c}`);
              connectors[c].forEach((d, i) => {
                if (i > 0) {
                  gCCS.append('line')
                    .attr('x1', connectors[c][i -1][1][0])
                    .attr('y1', connectors[c][i -1][1][1])
                    .attr('x2', d[0][0])
                    .attr('y2', d[0][1])
                    .attr('stroke', colors[c])
                    .attr('class', `connector ${c === SELECTED ? 'selected' : ''}`);
                } else {
                  gCCS.append('line')
                    .attr('x1', columnWidth)
                    .attr('y1', d[0][1])
                    .attr('x2', d[0][0])
                    .attr('y2', d[0][1])
                    .attr('stroke', colors[c])
                    .attr('class', `connector ${c === SELECTED ? 'selected' : ''}`);
                }
              });
              gCCS.append('line')
                .attr('x1', svgW - columnWidth)
                .attr('y1', connectors[c][connectors[c].length - 1][1][1])
                .attr('x2', connectors[c][connectors[c].length - 1][1][0])
                .attr('y2', connectors[c][connectors[c].length - 1][1][1])
                .attr('stroke', colors[c])
                .attr('class', `connector ${c === SELECTED ? 'selected' : ''}`);
            });

            // Summaries
            const gSY = svgP.append('g')
              .attr('class', 'summary-categories');
            const lastYear = data[years[years.length - 1]].sort((a, b) => b.numero - a.numero);
            lastYear.forEach((y, i) => {
              gSY.append('text')
                .attr('x', svgW - columnWidth)
                .attr('dx', 15)
                .attr('y', ((i + 1) * rowHeight) + (rowHeight / 2))
                .attr('class', `summary summary-category ${y.classe === SELECTED ? 'selected' : ''}`)
                .text(`${formatNumber(y.numero)} ${y.classe === SELECTED ? 'veicoli' : ''}`);
              gRH.append('circle')
                .attr('cx', svgW - columnWidth + 5)
                .attr('cy', ((i + 1) * rowHeight) + (rowHeight / 2))
                .attr('r', 3)
                .attr('fill', colors[y.classe]);
            });
          })();

          // Small Multiples
          (() => {
            const smallMultiples = {};
            let maxMax = Number.MIN_SAFE_INTEGER;
            let minMin = Number.MAX_SAFE_INTEGER;
            const chartHeight = 220;
            const margin = 80;
            const vMargin = 40;
            years.forEach((y, i) => {
              data[y].forEach((c, i) => {
                if (!smallMultiples[c.classe]) {
                  smallMultiples[c.classe] = [];
                }
                smallMultiples[c.classe].push(c.numero);
                if (c.numero > maxMax) {
                  maxMax = c.numero;
                }
                if (c.numero < minMin) {
                  minMin = c.numero;
                }
              });
            });
            console.log(smallMultiples, minMin, maxMax);
            const classes = Object.keys(smallMultiples);
            classes.sort().reverse();
            console.log(classes);

            const wrapper = d3.select('#small-m');
            classes.forEach((c) => {
              const div = wrapper.append('div')
                .attr('class', `single single-${c}`)
                .attr('id', c);
              const container = div.append('div')
                .attr('class', 'container');
              container.append('h3')
                .text(dictionary[c]);
              // const increase = ((smallMultiples[c][smallMultiples[c].length - 1]) / smallMultiples[c][0]) - 1;
              // container.append('h4')
              //   .attr('class', 'increase')
              //   .text(formatPercentage(increase));



              const scaleX = d3.scaleLinear()
                .range([margin, 420 - (margin)])
                .domain([0, 8]);
              const scaleY = d3.scaleLinear()
                .range([chartHeight - (vMargin), vMargin])
                .domain([minMin, maxMax]);

              const area = d3.area()
                .x(p => p.x)
                .y1(p => p.y)
                .y0(chartHeight - vMargin)
                .curve(d3.curveCatmullRom.alpha(0.5));
              
              const line = d3.line()
                .x(p => p.x)
                .y(p => p.y)
                .curve(d3.curveCatmullRom.alpha(0.5));
              const data = smallMultiples[c].map((d, i) => ({ x: scaleX(i), y: scaleY(d)}));

              const svgS = container.append('svg')
                .attr('width', 420)
                .attr('height', chartHeight)
                .attr('viewbox', `0 0 420 180`)
                .attr('preserveAspectRatio', 'xMidYMid meet');
              svgS.append('line')
                .attr('x1', margin)
                .attr('x2', 420 - (margin))
                .attr('y1', chartHeight - vMargin)
                .attr('y2', chartHeight - vMargin)
                .attr('stroke', colors.NEUTRAL)
                .attr('fill', 'none');
              svgS.append('line')
                .attr('x1', margin)
                .attr('x2', margin)
                .attr('y1', chartHeight - vMargin)
                .attr('y2', chartHeight - vMargin + 10)
                .attr('stroke', colors.NEUTRAL)
                .attr('fill', 'none');
              svgS.append('line')
                .attr('x1', 420 - (margin))
                .attr('x2', 420 - (margin))
                .attr('y1', chartHeight - vMargin)
                .attr('y2', chartHeight - vMargin + 10)
                .attr('stroke', colors.NEUTRAL)
                .attr('fill', 'none');
              svgS.append('text')
                .attr('x', 420 - (margin))
                .attr('y', chartHeight - vMargin + 20)
                .attr('class', 'axis-label')
                .attr('text-anchor', 'end')
                .attr('alignment-baseline', 'top')
                .text('2019');
              svgS.append('text')
                .attr('x', margin)
                .attr('y', chartHeight - vMargin + 20)
                .attr('class', 'axis-label')
                .attr('text-anchor', 'start')
                .attr('alignment-baseline', 'top')
                .text('2011');
              svgS.append('text')
                .attr('x', 210)
                .attr('y', chartHeight - vMargin + 20)
                .attr('class', 'axis-label')
                .attr('text-anchor', 'middle')
                .attr('alignment-baseline', 'top')
                .text('← Anni →');

              const min = smallMultiples[c][0];
              const max = smallMultiples[c][smallMultiples[c].length - 1];

              let string = (min < max) ? `+${formatNumber(Math.round(max / min))}×` : `-${formatNumber(Math.round(min / max))}×`;

              console.log(scaleY(min), scaleY(max));
              if (string === '-1×' || string === '+1×') {
                string = '≃';
              }
              const ypos = (Math.abs(scaleY(min) - scaleY(max)) > 15) ? scaleY(d3.mean([min, max])) : scaleY(d3.mean([min, max])) - 15;
              console.log(scaleY(min), scaleY(max), '=', ypos );


              svgS.append('line')
                .attr('x1', (margin))
                .attr('x2', 420 - (margin))
                .attr('y1', scaleY(min))
                .attr('y2', scaleY(min))
                .attr('stroke', colors.NEUTRAL)
                .attr('stroke-width', 1)
                .attr('stroke-dasharray', '1 1')
                .attr('fill', 'none');

              svgS.append('line')
                .attr('x1', (margin))
                .attr('x2', 420 - (margin))
                .attr('y1', scaleY(max))
                .attr('y2', scaleY(max))
                .attr('stroke', colors.NEUTRAL)
                .attr('stroke-width', 1)
                .attr('stroke-dasharray', '2 1')
                .attr('fill', 'none');

              svgS.append('path')
                .attr('d', area(data))
                .attr('class', `sm-area sm-area-${c}`)
                .attr('id', `sm-area-${c}`)
                .attr('stroke', 'none')
                .attr('fill', 'url(#fill)');
              svgS.append('path')
                .attr('d', line(data))
                .attr('class', `sm-line sm-line-${c}`)
                .attr('id', `sm-line-${c}`)
                .attr('stroke', colors[c])
                .attr('stroke-width', 2)
                .attr('fill', 'none');

              svgS.append('text')
                .attr('x', 210)
                .attr('y', ypos)
                .attr('class', 'annotation')
                .attr('text-anchor', 'middle')
                .attr('alignment-baseline', 'middle')
                .text(string);

              svgS.append('text')
                .attr('x', data[0].x)
                .attr('y', data[0].y)
                .attr('dx', -5)
                .attr('class', 'numbers')
                .attr('text-anchor', 'end')
                .attr('alignment-baseline', 'middle')
                .text(formatNumber(smallMultiples[c][0]));

              svgS.append('text')
                .attr('x', data[0].x)
                .attr('y', data[0].y)
                .attr('class', 'numbers')
                .attr('text-anchor', 'start')
                .attr('alignment-baseline', 'middle')
                .text('Veicoli');

              svgS.append('text')
                .attr('x', data[data.length - 1].x)
                .attr('dx', 5)
                .attr('y', data[data.length - 1].y)
                .attr('class', 'numbers')
                .attr('text-anchor', 'start')
                .attr('alignment-baseline', 'middle')
                .text(formatNumber(smallMultiples[c][smallMultiples[c].length - 1]));

            });
          })();

        });
    </script>
    <div class="assets">
      <svg>
        <defs>
          <pattern
            id="fill"
            width="3px"
            height="3px"
            patternUnits="userSpaceOnUse"
            patternContentUnits="userSpaceOnUse"
            viewBox="0 0 60 60"
            preserveAspectRatio="none"
            patternTransform="rotate(-45)"
          >
            <line
              x1="0"
              x2="90"
              y1="60"
              y2="60"
              stroke-width="10"
              stroke="#6F8884"
            />
          </pattern>
        </defs>
      </svg>
    </div>
  </body>
</html>
